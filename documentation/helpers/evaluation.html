<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>academic_crawler.helpers.evaluation API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>academic_crawler.helpers.evaluation</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import pprint
from collections import defaultdict

import numpy as np

from academic_crawler.config.utils import flatten
from academic_crawler.helpers.loaders import read_jsonlines_file
from academic_crawler.scrapers.templates import Person, Organization
from fuzzywuzzy import fuzz
from fuzzywuzzy import process

class Evaluator:
    def __init__(self,results_file,reference_file) -&gt; None:
        super().__init__()
        self.data_result = self.load_result_file(results_file)
        self.data_reference = self.load_result_file(reference_file)
        self.matches = None


    def load_result_file(self,fname):
        data = read_jsonlines_file(fname)
        data = flatten(data)
        data = Person.schema().load(data,many=True)
        data_sorted = sorted(data,key=lambda x: x.name)
        return data_sorted

    def evaluate_found_people(self):
        matches = []
        for person in self.data_result:
            person_ref = self.person_in_reference(person)
            if person_ref is not None:
                matches.append((person,person_ref))
        precision = len(matches)/len(self.data_result)
        recall = len(matches)/len(self.data_reference)
        f1 = 2*precision*recall/(precision+recall)
        self.matches = matches
        return {&#34;precision&#34;:precision,&#34;recall&#34;:recall,&#34;f1&#34;:f1,&#34;matches&#34;:matches}

    def evaluate_matches(self,matches=None):
        if not matches:
            matches = self.matches
        results = []
        for person,person_ref in matches:
            divison_matches,full_matches = self.affiliations_in_reference(person,person_ref)
            divisions_ref = set([aff.division for aff in person_ref.affiliations])
            not_found = set(person_ref.affiliations).difference(full_matches)
            item = {
                &#34;person&#34;:person.name,
                &#34;affiliations&#34;:person.affiliations,
                &#34;affiliations_ref&#34;:person_ref.affiliations,
                &#34;divison_matches&#34;:divison_matches,
                &#34;full_matches&#34;:full_matches,
                &#34;not_found&#34;:not_found,
                &#34;precision&#34;: len(full_matches)/len(person.affiliations),
                &#34;recall&#34;: len(full_matches)/len(person_ref.affiliations),
                &#34;precision_division&#34;: len(divison_matches)/len(person.affiliations),
                &#34;recall_division&#34;: len(divison_matches)/len(divisions_ref),
            }
            results.append(item)
        return results

    def affiliations_in_reference(self,person,person_ref):
        matches_division_position = set()
        divisions = set([aff.division for aff in person.affiliations])
        divisions_ref = set([aff.division for aff in person_ref.affiliations])
        matches_division = divisions.intersection(divisions_ref)
        for affiliation in person.affiliations:
            for affiliation_ref in person_ref.affiliations:
                if affiliation.division == affiliation_ref.division and affiliation.position == affiliation_ref.position:
                    matches_division_position.add(affiliation)
        return matches_division,matches_division_position



    def person_in_reference(self,person:Person):
        for i,person_ref in enumerate(self.data_reference):
            if person_ref.name == person.name:
                return person_ref
            elif person_ref.url == person.url:
                return person_ref
        return None

    def build_hierachical_tree(self,data:list[Person],main_org:Organization):
        tree_dict = defaultdict(set)

        for person in data:
            person.add_implicit_affiliations()
            parent = person.organization.parent
            org = person.organization
            while parent:
                tree_dict[parent.name].add(org.name)
                org = parent
                parent = parent.parent
            for affiliation in person.affiliations:
                parent = person.organization
                org = Organization(name=affiliation.division,url=parent.url,parent=parent,domain=parent.domain)
                if org.name != parent.name:
                    tree_dict[parent.name].add(org.name)
        return tree_dict

    def build_levels(self, tree,root):
        result = list()
        result.append([root])
        node = root
        level = 0
        print(result[level])

        while len(result[level]) &gt; 0:
            result.append([])
            for node in result[level]:
                print(node)
                for child in tree[node]:
                    result[level+1].append(child)
            level += 1
        return result




    def compare_levels(self,levels_res, tree_ref):
        min_length = min(len(levels_res),len(tree_ref))
        max_length = max(len(levels_res),len(tree_ref))
        res = []
        for i in range(min_length):
            res.append(levels_res[i].intersection(tree_ref[i]))

        for i in range(min_length,max_length):
            res.append(set())
        return res

class EntityInstanceMatcher:

    def __init__(self) -&gt; None:
        super().__init__()
        self.instances = []
        self.ref_instances =[]

    def add_instances(self,instances,ref_instances):
        self.instances = instances
        self.ref_instances = ref_instances
        self.matched_idxs = set()

    def compare_orgs(self):
        matches = []
        for i,instance in enumerate(self.instances):
            res = self.match_org(instance,i)
            if res[1] != -1:
                self.ref_instances.pop(res[1])
            matches.append(res)

        result = self.generate_confusion_matrix(matches)
        pprint.pprint(result)
        return result


    def match_org(self,org,index=-1):
        for i,org_ref in enumerate(self.ref_instances):
            if fuzz.partial_token_sort_ratio(org.name,org_ref.name) &gt; 80:
                return index,i
            elif fuzz.partial_token_sort_ratio(org.url,org_ref.url) &gt; 80:
                return index,i
        return index,-1

    def filter_people(self):
        url_set = set()
        result = []
        for i in range(len(self.instances)):
            if self.instances[i].url not in url_set:
                url_set.add(self.instances[i].url)
                result.append(self.instances[i])
        self.instances = result
        return True
    def compare_people(self):
        matches = []
        self.filter_people()
        for i,instance in enumerate(self.instances):
            res = self.match_person(instance,i)
            if res[1] != -1:
                self.ref_instances.pop(res[1])
            matches.append(res)
        result = self.generate_confusion_matrix(matches)
        pprint.pprint(result)
        return result

    def match_person(self,person,index=-1):
        for i,person_ref in enumerate(self.ref_instances):
            if fuzz.partial_token_sort_ratio(person.url, person_ref.url) &gt; 80:
                return index,i
            elif fuzz.partial_token_sort_ratio(person.name,person_ref.name) &gt; 80:
                return index,i
        return index,-1
    def compare_affiliations(self):
        pass

    def generate_confusion_matrix(self,matches):
        TP = 0
        FP = 0
        used_reference = set()
        for match in matches:
            if match[1] != -1:
                TP += 1
                used_reference.add(match[1])
            else:
                FP += 1
        #remaining_reference = set([i for i in range(len(self.ref_instances))]).difference(used_reference)
        FN = len(self.ref_instances)
        confusion_matrix = np.array([[TP, FP], [FN, 0]])
        precision = TP / (TP + FP)
        recall = TP / (TP + FN)
        f1 = 2 * (precision * recall) / (precision + recall)

        return {&#39;confusion_matrix&#39;: confusion_matrix, &#39;precision&#39;: precision, &#39;recall&#39;: recall, &#39;f1&#39;: f1}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher"><code class="flex name class">
<span>class <span class="ident">EntityInstanceMatcher</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EntityInstanceMatcher:

    def __init__(self) -&gt; None:
        super().__init__()
        self.instances = []
        self.ref_instances =[]

    def add_instances(self,instances,ref_instances):
        self.instances = instances
        self.ref_instances = ref_instances
        self.matched_idxs = set()

    def compare_orgs(self):
        matches = []
        for i,instance in enumerate(self.instances):
            res = self.match_org(instance,i)
            if res[1] != -1:
                self.ref_instances.pop(res[1])
            matches.append(res)

        result = self.generate_confusion_matrix(matches)
        pprint.pprint(result)
        return result


    def match_org(self,org,index=-1):
        for i,org_ref in enumerate(self.ref_instances):
            if fuzz.partial_token_sort_ratio(org.name,org_ref.name) &gt; 80:
                return index,i
            elif fuzz.partial_token_sort_ratio(org.url,org_ref.url) &gt; 80:
                return index,i
        return index,-1

    def filter_people(self):
        url_set = set()
        result = []
        for i in range(len(self.instances)):
            if self.instances[i].url not in url_set:
                url_set.add(self.instances[i].url)
                result.append(self.instances[i])
        self.instances = result
        return True
    def compare_people(self):
        matches = []
        self.filter_people()
        for i,instance in enumerate(self.instances):
            res = self.match_person(instance,i)
            if res[1] != -1:
                self.ref_instances.pop(res[1])
            matches.append(res)
        result = self.generate_confusion_matrix(matches)
        pprint.pprint(result)
        return result

    def match_person(self,person,index=-1):
        for i,person_ref in enumerate(self.ref_instances):
            if fuzz.partial_token_sort_ratio(person.url, person_ref.url) &gt; 80:
                return index,i
            elif fuzz.partial_token_sort_ratio(person.name,person_ref.name) &gt; 80:
                return index,i
        return index,-1
    def compare_affiliations(self):
        pass

    def generate_confusion_matrix(self,matches):
        TP = 0
        FP = 0
        used_reference = set()
        for match in matches:
            if match[1] != -1:
                TP += 1
                used_reference.add(match[1])
            else:
                FP += 1
        #remaining_reference = set([i for i in range(len(self.ref_instances))]).difference(used_reference)
        FN = len(self.ref_instances)
        confusion_matrix = np.array([[TP, FP], [FN, 0]])
        precision = TP / (TP + FP)
        recall = TP / (TP + FN)
        f1 = 2 * (precision * recall) / (precision + recall)

        return {&#39;confusion_matrix&#39;: confusion_matrix, &#39;precision&#39;: precision, &#39;recall&#39;: recall, &#39;f1&#39;: f1}</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.add_instances"><code class="name flex">
<span>def <span class="ident">add_instances</span></span>(<span>self, instances, ref_instances)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_instances(self,instances,ref_instances):
    self.instances = instances
    self.ref_instances = ref_instances
    self.matched_idxs = set()</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_affiliations"><code class="name flex">
<span>def <span class="ident">compare_affiliations</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_affiliations(self):
    pass</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_orgs"><code class="name flex">
<span>def <span class="ident">compare_orgs</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_orgs(self):
    matches = []
    for i,instance in enumerate(self.instances):
        res = self.match_org(instance,i)
        if res[1] != -1:
            self.ref_instances.pop(res[1])
        matches.append(res)

    result = self.generate_confusion_matrix(matches)
    pprint.pprint(result)
    return result</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_people"><code class="name flex">
<span>def <span class="ident">compare_people</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_people(self):
    matches = []
    self.filter_people()
    for i,instance in enumerate(self.instances):
        res = self.match_person(instance,i)
        if res[1] != -1:
            self.ref_instances.pop(res[1])
        matches.append(res)
    result = self.generate_confusion_matrix(matches)
    pprint.pprint(result)
    return result</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.filter_people"><code class="name flex">
<span>def <span class="ident">filter_people</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter_people(self):
    url_set = set()
    result = []
    for i in range(len(self.instances)):
        if self.instances[i].url not in url_set:
            url_set.add(self.instances[i].url)
            result.append(self.instances[i])
    self.instances = result
    return True</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.generate_confusion_matrix"><code class="name flex">
<span>def <span class="ident">generate_confusion_matrix</span></span>(<span>self, matches)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_confusion_matrix(self,matches):
    TP = 0
    FP = 0
    used_reference = set()
    for match in matches:
        if match[1] != -1:
            TP += 1
            used_reference.add(match[1])
        else:
            FP += 1
    #remaining_reference = set([i for i in range(len(self.ref_instances))]).difference(used_reference)
    FN = len(self.ref_instances)
    confusion_matrix = np.array([[TP, FP], [FN, 0]])
    precision = TP / (TP + FP)
    recall = TP / (TP + FN)
    f1 = 2 * (precision * recall) / (precision + recall)

    return {&#39;confusion_matrix&#39;: confusion_matrix, &#39;precision&#39;: precision, &#39;recall&#39;: recall, &#39;f1&#39;: f1}</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.match_org"><code class="name flex">
<span>def <span class="ident">match_org</span></span>(<span>self, org, index=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_org(self,org,index=-1):
    for i,org_ref in enumerate(self.ref_instances):
        if fuzz.partial_token_sort_ratio(org.name,org_ref.name) &gt; 80:
            return index,i
        elif fuzz.partial_token_sort_ratio(org.url,org_ref.url) &gt; 80:
            return index,i
    return index,-1</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.EntityInstanceMatcher.match_person"><code class="name flex">
<span>def <span class="ident">match_person</span></span>(<span>self, person, index=-1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_person(self,person,index=-1):
    for i,person_ref in enumerate(self.ref_instances):
        if fuzz.partial_token_sort_ratio(person.url, person_ref.url) &gt; 80:
            return index,i
        elif fuzz.partial_token_sort_ratio(person.name,person_ref.name) &gt; 80:
            return index,i
    return index,-1</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator"><code class="flex name class">
<span>class <span class="ident">Evaluator</span></span>
<span>(</span><span>results_file, reference_file)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Evaluator:
    def __init__(self,results_file,reference_file) -&gt; None:
        super().__init__()
        self.data_result = self.load_result_file(results_file)
        self.data_reference = self.load_result_file(reference_file)
        self.matches = None


    def load_result_file(self,fname):
        data = read_jsonlines_file(fname)
        data = flatten(data)
        data = Person.schema().load(data,many=True)
        data_sorted = sorted(data,key=lambda x: x.name)
        return data_sorted

    def evaluate_found_people(self):
        matches = []
        for person in self.data_result:
            person_ref = self.person_in_reference(person)
            if person_ref is not None:
                matches.append((person,person_ref))
        precision = len(matches)/len(self.data_result)
        recall = len(matches)/len(self.data_reference)
        f1 = 2*precision*recall/(precision+recall)
        self.matches = matches
        return {&#34;precision&#34;:precision,&#34;recall&#34;:recall,&#34;f1&#34;:f1,&#34;matches&#34;:matches}

    def evaluate_matches(self,matches=None):
        if not matches:
            matches = self.matches
        results = []
        for person,person_ref in matches:
            divison_matches,full_matches = self.affiliations_in_reference(person,person_ref)
            divisions_ref = set([aff.division for aff in person_ref.affiliations])
            not_found = set(person_ref.affiliations).difference(full_matches)
            item = {
                &#34;person&#34;:person.name,
                &#34;affiliations&#34;:person.affiliations,
                &#34;affiliations_ref&#34;:person_ref.affiliations,
                &#34;divison_matches&#34;:divison_matches,
                &#34;full_matches&#34;:full_matches,
                &#34;not_found&#34;:not_found,
                &#34;precision&#34;: len(full_matches)/len(person.affiliations),
                &#34;recall&#34;: len(full_matches)/len(person_ref.affiliations),
                &#34;precision_division&#34;: len(divison_matches)/len(person.affiliations),
                &#34;recall_division&#34;: len(divison_matches)/len(divisions_ref),
            }
            results.append(item)
        return results

    def affiliations_in_reference(self,person,person_ref):
        matches_division_position = set()
        divisions = set([aff.division for aff in person.affiliations])
        divisions_ref = set([aff.division for aff in person_ref.affiliations])
        matches_division = divisions.intersection(divisions_ref)
        for affiliation in person.affiliations:
            for affiliation_ref in person_ref.affiliations:
                if affiliation.division == affiliation_ref.division and affiliation.position == affiliation_ref.position:
                    matches_division_position.add(affiliation)
        return matches_division,matches_division_position



    def person_in_reference(self,person:Person):
        for i,person_ref in enumerate(self.data_reference):
            if person_ref.name == person.name:
                return person_ref
            elif person_ref.url == person.url:
                return person_ref
        return None

    def build_hierachical_tree(self,data:list[Person],main_org:Organization):
        tree_dict = defaultdict(set)

        for person in data:
            person.add_implicit_affiliations()
            parent = person.organization.parent
            org = person.organization
            while parent:
                tree_dict[parent.name].add(org.name)
                org = parent
                parent = parent.parent
            for affiliation in person.affiliations:
                parent = person.organization
                org = Organization(name=affiliation.division,url=parent.url,parent=parent,domain=parent.domain)
                if org.name != parent.name:
                    tree_dict[parent.name].add(org.name)
        return tree_dict

    def build_levels(self, tree,root):
        result = list()
        result.append([root])
        node = root
        level = 0
        print(result[level])

        while len(result[level]) &gt; 0:
            result.append([])
            for node in result[level]:
                print(node)
                for child in tree[node]:
                    result[level+1].append(child)
            level += 1
        return result




    def compare_levels(self,levels_res, tree_ref):
        min_length = min(len(levels_res),len(tree_ref))
        max_length = max(len(levels_res),len(tree_ref))
        res = []
        for i in range(min_length):
            res.append(levels_res[i].intersection(tree_ref[i]))

        for i in range(min_length,max_length):
            res.append(set())
        return res</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="academic_crawler.helpers.evaluation.Evaluator.affiliations_in_reference"><code class="name flex">
<span>def <span class="ident">affiliations_in_reference</span></span>(<span>self, person, person_ref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def affiliations_in_reference(self,person,person_ref):
    matches_division_position = set()
    divisions = set([aff.division for aff in person.affiliations])
    divisions_ref = set([aff.division for aff in person_ref.affiliations])
    matches_division = divisions.intersection(divisions_ref)
    for affiliation in person.affiliations:
        for affiliation_ref in person_ref.affiliations:
            if affiliation.division == affiliation_ref.division and affiliation.position == affiliation_ref.position:
                matches_division_position.add(affiliation)
    return matches_division,matches_division_position</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.build_hierachical_tree"><code class="name flex">
<span>def <span class="ident">build_hierachical_tree</span></span>(<span>self, data: list[<a title="academic_crawler.scrapers.templates.Person" href="../scrapers/templates/index.html#academic_crawler.scrapers.templates.Person">Person</a>], main_org: <a title="academic_crawler.scrapers.templates.Organization" href="../scrapers/templates/index.html#academic_crawler.scrapers.templates.Organization">Organization</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_hierachical_tree(self,data:list[Person],main_org:Organization):
    tree_dict = defaultdict(set)

    for person in data:
        person.add_implicit_affiliations()
        parent = person.organization.parent
        org = person.organization
        while parent:
            tree_dict[parent.name].add(org.name)
            org = parent
            parent = parent.parent
        for affiliation in person.affiliations:
            parent = person.organization
            org = Organization(name=affiliation.division,url=parent.url,parent=parent,domain=parent.domain)
            if org.name != parent.name:
                tree_dict[parent.name].add(org.name)
    return tree_dict</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.build_levels"><code class="name flex">
<span>def <span class="ident">build_levels</span></span>(<span>self, tree, root)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_levels(self, tree,root):
    result = list()
    result.append([root])
    node = root
    level = 0
    print(result[level])

    while len(result[level]) &gt; 0:
        result.append([])
        for node in result[level]:
            print(node)
            for child in tree[node]:
                result[level+1].append(child)
        level += 1
    return result</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.compare_levels"><code class="name flex">
<span>def <span class="ident">compare_levels</span></span>(<span>self, levels_res, tree_ref)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compare_levels(self,levels_res, tree_ref):
    min_length = min(len(levels_res),len(tree_ref))
    max_length = max(len(levels_res),len(tree_ref))
    res = []
    for i in range(min_length):
        res.append(levels_res[i].intersection(tree_ref[i]))

    for i in range(min_length,max_length):
        res.append(set())
    return res</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.evaluate_found_people"><code class="name flex">
<span>def <span class="ident">evaluate_found_people</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_found_people(self):
    matches = []
    for person in self.data_result:
        person_ref = self.person_in_reference(person)
        if person_ref is not None:
            matches.append((person,person_ref))
    precision = len(matches)/len(self.data_result)
    recall = len(matches)/len(self.data_reference)
    f1 = 2*precision*recall/(precision+recall)
    self.matches = matches
    return {&#34;precision&#34;:precision,&#34;recall&#34;:recall,&#34;f1&#34;:f1,&#34;matches&#34;:matches}</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.evaluate_matches"><code class="name flex">
<span>def <span class="ident">evaluate_matches</span></span>(<span>self, matches=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def evaluate_matches(self,matches=None):
    if not matches:
        matches = self.matches
    results = []
    for person,person_ref in matches:
        divison_matches,full_matches = self.affiliations_in_reference(person,person_ref)
        divisions_ref = set([aff.division for aff in person_ref.affiliations])
        not_found = set(person_ref.affiliations).difference(full_matches)
        item = {
            &#34;person&#34;:person.name,
            &#34;affiliations&#34;:person.affiliations,
            &#34;affiliations_ref&#34;:person_ref.affiliations,
            &#34;divison_matches&#34;:divison_matches,
            &#34;full_matches&#34;:full_matches,
            &#34;not_found&#34;:not_found,
            &#34;precision&#34;: len(full_matches)/len(person.affiliations),
            &#34;recall&#34;: len(full_matches)/len(person_ref.affiliations),
            &#34;precision_division&#34;: len(divison_matches)/len(person.affiliations),
            &#34;recall_division&#34;: len(divison_matches)/len(divisions_ref),
        }
        results.append(item)
    return results</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.load_result_file"><code class="name flex">
<span>def <span class="ident">load_result_file</span></span>(<span>self, fname)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def load_result_file(self,fname):
    data = read_jsonlines_file(fname)
    data = flatten(data)
    data = Person.schema().load(data,many=True)
    data_sorted = sorted(data,key=lambda x: x.name)
    return data_sorted</code></pre>
</details>
</dd>
<dt id="academic_crawler.helpers.evaluation.Evaluator.person_in_reference"><code class="name flex">
<span>def <span class="ident">person_in_reference</span></span>(<span>self, person: <a title="academic_crawler.scrapers.templates.Person" href="../scrapers/templates/index.html#academic_crawler.scrapers.templates.Person">Person</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def person_in_reference(self,person:Person):
    for i,person_ref in enumerate(self.data_reference):
        if person_ref.name == person.name:
            return person_ref
        elif person_ref.url == person.url:
            return person_ref
    return None</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="academic_crawler.helpers" href="index.html">academic_crawler.helpers</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher">EntityInstanceMatcher</a></code></h4>
<ul class="">
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.add_instances" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.add_instances">add_instances</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_affiliations" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_affiliations">compare_affiliations</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_orgs" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_orgs">compare_orgs</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_people" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.compare_people">compare_people</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.filter_people" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.filter_people">filter_people</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.generate_confusion_matrix" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.generate_confusion_matrix">generate_confusion_matrix</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.match_org" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.match_org">match_org</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.EntityInstanceMatcher.match_person" href="#academic_crawler.helpers.evaluation.EntityInstanceMatcher.match_person">match_person</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="academic_crawler.helpers.evaluation.Evaluator" href="#academic_crawler.helpers.evaluation.Evaluator">Evaluator</a></code></h4>
<ul class="">
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.affiliations_in_reference" href="#academic_crawler.helpers.evaluation.Evaluator.affiliations_in_reference">affiliations_in_reference</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.build_hierachical_tree" href="#academic_crawler.helpers.evaluation.Evaluator.build_hierachical_tree">build_hierachical_tree</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.build_levels" href="#academic_crawler.helpers.evaluation.Evaluator.build_levels">build_levels</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.compare_levels" href="#academic_crawler.helpers.evaluation.Evaluator.compare_levels">compare_levels</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.evaluate_found_people" href="#academic_crawler.helpers.evaluation.Evaluator.evaluate_found_people">evaluate_found_people</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.evaluate_matches" href="#academic_crawler.helpers.evaluation.Evaluator.evaluate_matches">evaluate_matches</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.load_result_file" href="#academic_crawler.helpers.evaluation.Evaluator.load_result_file">load_result_file</a></code></li>
<li><code><a title="academic_crawler.helpers.evaluation.Evaluator.person_in_reference" href="#academic_crawler.helpers.evaluation.Evaluator.person_in_reference">person_in_reference</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>